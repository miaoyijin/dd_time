一：
1：  hbase对事务支持不友好，不支持可重复度隔离级别，性能差
【
只支持行级事务


批量写入多行的写写并发:

HBase支持批量写入（或批量更新），即一个线程同时更新同一个Region中的多行记录。
那如何保证当前事务中的批量写入与其他事务中的批量写入的并发控制呢？思路还是一样的，使用行锁。但这里需要注意的是必须使用两阶段锁协议，即：

(1) 获取所有待写入（更新）行记录的行锁

(2) 开始执行写入（更新）操作

(3) 写入完成之后再统一释放所有行记录的行锁
】

2：  不支持join
3：  不支持丰富的查询功能【需要第三方插件phoenix】

(5: 支持limit业务)

4：查询性能较差（不稳定） 见如下lsm原理（需要遍历多个sstable,增加磁盘io）

二： lsm 
1：查询： 
先到Memtable和Imutable memtable查找，如果查不到就到SSTable中查找，查找每个SStable，直到找到数据

2：查询详细过程
要让SStable按key排序，那就不能顺序存储磁盘了呀（即无法存储的时候立即写入磁盘）！！的确是这样，虽然也可以使用类似B-tree来实现磁盘上的排序存储，但转换下思路，其实将数据先保存在内存中其实更加方便。

具体实现流程，是在内存中维护一个类似TreeMap的数据结构用于存储数据（TreeMap底层是基于红黑树对存储的key进行排序的。无论我们按照什么样的顺序存储数据，TreeMap总是会将数据按照key进行排序）。
这个TreeMap称为内存表，当内存表超过一定阈值的时候，就将其写入到磁盘中，成为SStable，因为已经排好序，所以写入的效率其实比想象的要高。后期再对磁盘中的SStable进行压缩与合并操作。

当需要根据key检索的时候，会先去内存表中检索，找不到再去最新的SStable，再去次新的SStable，直到遍历完全部


3： 什么是SSTable
Sorted String Table




